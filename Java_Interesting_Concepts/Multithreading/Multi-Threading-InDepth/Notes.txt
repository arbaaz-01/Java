Java MultiThreading

Thread Class Method:run()1. Thread.sleep(millisecond)2. t1.join() -> wait to finish the thread the execution3. t1.setPriority() Thread.Setting thread name using constructorinterrupt method, yield methodDeaemon Thread setDaemon(true)Synchronizationsynchronized keyword applied on mehtod accessing same object or resourcesynchronized block for specific thing in a method when not want to apply on whole method Critical Section, Race Condition, mutual exclusionDisadvantge of Synchronized:1. No Fairness of Lock2. Blocking -> Indefinite waiting for some thread3. No Interruptibility4. No ides of Read/Write LockingThese can be overcome using Manual Locking (Reentrant).Locks:- Intrinsic: Java ke har object mai lock hota hai jab synchronized keyword use karte hai tab wahi chalta hai. No control to user. Can cause indefinite waiting for other threads (Starvation).Explicit: Lock class provide more advance locks and programmer can handle and take control on their own as per requirements java.util.concurrent.lockprivate Lock lock = new ReentrantLock();Lock is interface, ReentrantLock is it's implementationlock.lock(), .tryLock(), .unlock(), .lockInterruptibility()tryLock with time and without timeWhy called ReentrantLock?Reentrant Lock avoid Deadlock situationLock ka count maintain hota hai, Each lock call must be paired with unlock() call.Fairness and Unfairness of the ReentrantLock.